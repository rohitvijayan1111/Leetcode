TEMPLATE FOR DFS:

if(not root):
  return

DS(left),dfs(right)


1)BFS 

2)DFS-TOP DOWN AND BOTTOM UP-BOTTOM UP EFFICIENT

3)LEVEL ORDER TRAVERSAL

4)IN SOME QUESTIONS WE USE LEVEL ORDER TRAVERSAL WE NOT ONLY APPEND THE NODE TO THE QUEUE BUT ALSO PASS THE ROW,COLUMN/OR ASSIGN A NO TO THE NODE AND ALONG WITH IT ADD IT TO
THE QUEUE

What i learned: When you have to traverse back use a map to store the parent node


problems where we travel with equal speed in all possible direction its BFS


count of a binary tree (2^n)-1


> you have a perfect binary tree, then given only the PREORDER and POSTORDER, you can construct your unique binary tree
>CREATING AN UNIQUE BINARY TREE:
1)INORDER IS MUST(need to know what is given)+ preorder/postorder

