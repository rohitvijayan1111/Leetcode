FOR A PROBLEM WHERE WE ARE A GIVEN A RANDOM NODE TO DELETE WITHOUT THE HEAD NODE
SOL:THE ONLY OPTION IS TO COPY THE NEXT NODE DATA TO THE CURRENT NODE AND CHANGE THE NEXT POINTER TO NEXT.NEXT
------------------------------------------------------------------------------------------------------------------
1)Tortoise and hare method
    i)SLOW BY ONE STEP AND FAST BY TWO STEPS
    ii)we can initially move the fast pointer to a certain distance and then move the slow and the fast pointer by 1
2)142. Linked List Cycle II- in this once we detect the cycle it does not mean that it is the start node of the loop
so what you have to do is :
use an another pointer from head and move it one step and also move the slow pointer utimately both will meet that 
is the starting point of the loop
===============================================================================================================
3)328. Odd Even Linked List
here we had been asked to create a linkedlist where first half of the index have odd index and second half has even indexes
so i tried if we can reach the middle element and make the first half odd index and second half even indexes. BUt for odd and even length 
it didnt have any logic.
so THe solution was to maintain a new linkedlist for odd and even and later join (THE NODES ARE THE OLD ONES so i think thay way it dint have extra memory)
----------------------------------------------------------------------------------------------------------
4)suppose u want to access the end of the linked list for example in adding 1 to a linked list and i am asked 
to provide a solution without reversing the no . The best option is to use recursion (AS IT HAS BACKTRACKING)
